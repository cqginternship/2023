### STL: Контейнеры и итераторы
# Лабораторная работа N 3
### Задание к выполнению лабораторной работы.

Играем в "создателей STL". Реализовать шаблонный класс `simple_vector<T>`, имеющий в интерфейсе следующие функции:
      
Функция добавления элемента
```cpp
   void push_back(const T& i_element);
```
Функция предварительного резервирования памяти:
```cpp
   void reserve(size_t i_capacity);
```
Функция расширения вектора до заданного количества элементов (с инициализацией неинициализированных элементов заданным значением):
```cpp
   void resize(size_t i_size, const T& i_value = T());
```

оператор [] доступа к элементу для его последующей считывания и/или модификации;
```cpp
   T& operator[](size_t i_index);
```

Функция, возвращающая признак пустоты контейнера:
```cpp
   bool empty() const;
```

Функция, возвращающая размер (количество) вектора:
```cpp
   size_t size() const;
```

Реализация `simple_vector` должна гарантировать последовательное расположение элементов в памяти. Предполагается, что `simple_vector` будет выделять в куче, динамически  (по мере необходимости, с некоторым запасом, чтобы избежать слишком частых перевыделений памяти). 

На всякий случай – подразумевается, что нельзя использовать стандартные контейнеры в реализации `simple_vector`.

Написать консольное приложение, которое одновременно использует как `simple_vector`, так и `std::vector`; обращается ко всем функциям, предоставляемым `simple_vector`; проверяет, что результаты идентичных действий над `simple_vector` и `std::vector` одинаковы.
